/*
 * JPQL grammar for Solr translation
 */
Package org.ut.biolab.medsavant.shared.query.parser;

Helpers
    whitespace_char = ' ' | '\t' | '\n' | '\r';
    letter_char = ['A'..'Z'] | ['a'..'z'];
    digit_char = ['0'..'9'];
    any_char = [0..0xffff];
    identification_variable_tail = letter_char | digit_char | '_';
    singlequote_char = ''';
    doublequote_char = '"';
    single_quoted_string_literal = singlequote_char [any_char - singlequote_char]* singlequote_char;
    double_quoted_string_literal = doublequote_char [any_char - doublequote_char]* doublequote_char;

    equal = '=';

    /*
     * Lowercase support
     */
    a = ['a' + 'A'];
    b = ['b' + 'B'];
    c = ['c' + 'C'];
    d = ['d' + 'D'];
    e = ['e' + 'E'];
    f = ['f' + 'F'];
    g = ['g' + 'G'];
    h = ['h' + 'H'];
    i = ['i' + 'I'];
    j = ['j' + 'J'];
    k = ['k' + 'K'];
    l = ['l' + 'L'];
    m = ['m' + 'M'];
    n = ['n' + 'N'];
    o = ['o' + 'O'];
    p = ['p' + 'P'];
    q = ['q' + 'Q'];
    r = ['r' + 'R'];
    s = ['s' + 'S'];
    t = ['t' + 'T'];
    u = ['u' + 'U'];
    v = ['v' + 'V'];
    w = ['w' + 'W'];
    x = ['x' + 'X'];
    y = ['y' + 'Y'];
    z = ['z' + 'Z'];

    /*
     *  Keywords
     */
    current_date = c u r r e n t '_' d a t e;
    current_time = c u r r e n t '_' t i m e;
    current_timestamp = c u r r e n t '_' t i m e s t a m p;
    true = t r u e;
    false = f a l s e;
    avg = a v g;
    max = m a x;
    min = m i n;
    sum = s u m;
    asc = a s c;
    desc = d e s c;
    all = a l l;
    any = a n y;
    some = s o m e;
    leading = l e a d i n g;
    trailing = t r a i l i n g;
    both = b o t h;

Tokens
    whitespace_char = whitespace_char+;
    comma_char = ',';
    left_bracket = '(';
    right_bracket = ')';
    dot = '.';

    // keywords
    abs = a b s;
    and = a n d;
    as = a s;
    between = b e t w e e n;
    by = b y;
    concat = c o n c a t;
    count = c o u n t;
    distinct = d i s t i n c t;
    empty = e m p t y;
    escape = e s c a p e;
    exists = e x i s t s;
    fetch = f e t c h;
    from = f r o m;
    group = g r o u p;
    having = h a v i n g;
    in = i n;
    inner = i n n e r;
    is = i s;
    left = l e f t;
    length = l e n g t h;
    like = l i k e;
    locate = l o c a t e;
    lower = l o w e r;
    member = m e m b e r;
    mod = m o d;
    not = n o t;
    null = n u l l;
    of = o f;
    or = o r;
    object = o b j e c t;
    order = o r d e r;
    outer = o u t e r;
    select = s e l e c t;
    set = s e t;
    update = u p d a t e;
    delete = d e l e t e;
    size = s i z e;
    sqrt = s q r t;
    substring = s u b s t r i n g;
    trim = t r i m;
    upper = u p p e r;
    where = w h e r e;

    boolean_literal = true | false;
    integer_literal = digit_char+;
    float_literal = digit_char+ '.' digit_char* ('e' ('+' | '-')? digit_char+)?;
    string_literal = single_quoted_string_literal | double_quoted_string_literal;

    input_parameter = (':' identification_variable_tail+) | ('?' digit_char+);

    aggregate_func = avg | max | min | sum;
    order_direction = asc | desc;
    comparison_operator = '=' | '>' | '>=' | '<' | '<=' | '<>' ;
    add_sub = '+' | '-';
    mul_div = '*' | '/';
    functions_returning_datetime = current_date | current_time | current_timestamp;
    trim_specification = leading | trailing | both;

    identification_variable= letter_char identification_variable_tail*;

Ignored Tokens
    whitespace_char;

Productions

statement =
    {sel} select_statement |
    {upd} update_statement |
    {del} delete_statement;

select_statement =
    select_clause from_clause where_clause? groupby_clause? having_clause? orderby_clause?;

update_statement =
    update_clause where_clause?;

delete_statement =
    delete_clause where_clause?;

from_clause =
    from from_list;

from_list =
    {single} identification_variable_declaration;

identification_variable_declaration =
    range_variable_declaration;

range_variable_declaration =
    abstract_schema_name as? variable;

select_clause =
    select distinct? select_list;

delete_clause =
    delete from range_variable_declaration delete_variable_remainder?;

delete_variable_remainder =
    as? variable;

update_clause =
    update range_variable_declaration set update_field_list;

update_field_list =
    {single} update_field |
    update_field comma_char update_field_list;

update_field =
    path_expression comparison_operator new_value;

new_value =
    {literal} literal |
    {param} input_parameter;


select_list =
    {single} select_expression |
    select_expression comma_char select_list;

select_expression =
    {path} path_expression |
    {agr} aggregate_expression |
    {object} object left_bracket_prod path_expression right_bracket_prod;

aggregate_expression =
    {func} aggregate_func left_bracket_prod distinct? path_expression right_bracket_prod |
    {count} count left_bracket_prod distinct? count_arg right_bracket_prod;

count_arg =
    {path} path_expression;

where_clause =
    where conditional_expression;

groupby_clause =
    group by groupby_list;

groupby_list =
    {single} groupby_item |
    groupby_list comma_char groupby_item;

groupby_item =
    path_expression;

having_clause =
    having conditional_expression;

orderby_clause =
    order by orderby_list;

orderby_list =
    {single} orderby_item |
    orderby_item comma_char orderby_list;

orderby_item =
    path_expression order_direction?;

simple_select_clause =
    select distinct? simple_select_expression;

simple_select_expression =
    {path} path_expression |
    {agr} aggregate_expression;

conditional_expression =
    {single} conditional_term |
    conditional_expression or conditional_term;

conditional_term =
    {single} conditional_factor |
    conditional_term and conditional_factor;

conditional_factor =
    not? conditional_primary;

conditional_primary =
    simple_cond_expression |
    {br} left_bracket_prod conditional_expression right_bracket_prod;

simple_cond_expression =
    arithmetic_expression simple_conditional_expression_remainder;

simple_conditional_expression_remainder =
    {compare} comparison_expression |
    {not} not? condition_with_not_expression |
    {is} is not? is_expression;

condition_with_not_expression =
    {between} between_expression |
    {like} like_expression |
    {in} in_expression |
    {member} collection_member_expression;

between_expression =
    between [a]:arithmetic_expression and [b]:arithmetic_expression;

is_expression =
    {null} null_comparison_expression |
    {empty} empty_collection_comparison_expression;

in_expression =
    in left_bracket_prod in_list right_bracket_prod;

in_list =
    {single} in_item |
    in_item comma_char in_list;

in_item =
    {literal} literal |
    {param} input_parameter;

like_expression =
    not? like pattern_value escape_expression?;

escape_expression =
    escape escape_character;

null_comparison_expression =
    null;

empty_collection_comparison_expression =
    empty;

collection_member_expression =
    member of? path_expression;

comparison_expression =
    comparison_operator comparison_expression_right_operand;

comparison_expression_right_operand =
    {math} arithmetic_expression;

arithmetic_expression =
    simple_arithmetic_expression;

simple_arithmetic_expression =
    {single} arithmetic_term |
    arithmetic_term add_sub simple_arithmetic_expression;

arithmetic_term =
    {single} arithmetic_factor |
    arithmetic_term  mul_div  arithmetic_factor;

arithmetic_factor =
    [sign]:add_sub? arithmetic_primary;

arithmetic_primary =
    {agr} aggregate_expression |
    {path} path_expression |
    {funcnum} functions_returning_numerics |
    {functime} functions_returning_datetime |
    {funcstr} functions_returning_strings |
    {param} input_parameter |
    {constant} literal |
    {br} left_bracket_prod simple_arithmetic_expression right_bracket_prod;

functions_returning_numerics =
    {length} length left_bracket_prod string_primary right_bracket_prod |
    {locate} locate left_bracket_prod [what]:string_primary comma_char [where]:string_primary start_spec? right_bracket_prod |
    {abs} abs left_bracket_prod simple_arithmetic_expression right_bracket_prod |
    {sqrt} sqrt left_bracket_prod simple_arithmetic_expression right_bracket_prod |
    {mod} mod left_bracket_prod [dividend]:simple_arithmetic_expression comma_char [divisor]:simple_arithmetic_expression right_bracket_prod |
    {size} size left_bracket_prod path_expression right_bracket_prod;

string_primary =
    {const} string_literal |
    {func} functions_returning_strings |
    {param} input_parameter |
    {path} path_expression;

start_spec =
    comma_char [start]:simple_arithmetic_expression;

functions_returning_strings =
    {concat} concat left_bracket_prod [s1]:string_primary comma_char [s2]:string_primary right_bracket_prod |
    {substring} substring left_bracket_prod string_primary [c1]:comma_char [start]:simple_arithmetic_expression [c2]:comma_char [length]:simple_arithmetic_expression right_bracket_prod |
    {trim} trim left_bracket_prod trim_desc? string_primary right_bracket_prod |
    {lower} lower left_bracket_prod string_primary right_bracket_prod |
    {upper} upper left_bracket_prod string_primary right_bracket_prod;

trim_desc = trim_specification? trim_character? from;

abstract_schema_name =
    identification_variable|
    {x} object_declaration;

object_declaration =
	identification_variable left_bracket_prod x_class_name right_bracket_prod;

x_class_name =
	identification_variable|
	{quoted} string_literal;

variable =
    identification_variable;

path_expression =
    {x} single_valued_association_path_expression |
    {xprop} object_declaration dot [property]:identification_variable;

literal =
    {num} numeric_literal |
    {bool} boolean_literal |
    {str} string_literal;

numeric_literal =
    {integer} integer_literal |
    {float} float_literal;

pattern_value =
    {str} string_literal |
    {param} input_parameter;

escape_character =
    string_literal;

trim_character =
    string_literal;

single_valued_association_path_expression =
    {iddot} identification_variable dot single_valued_association_field |
    {single_valued_association_field} single_valued_association_field;

single_valued_association_field =
    identification_variable;

left_bracket_prod =
    left_bracket;

right_bracket_prod =
    right_bracket;

